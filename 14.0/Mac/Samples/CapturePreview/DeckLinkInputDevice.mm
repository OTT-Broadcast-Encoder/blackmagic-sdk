/* -LICENSE-START-
 ** Copyright (c) 2011 Blackmagic Design
 **  
 ** Permission is hereby granted, free of charge, to any person or organization 
 ** obtaining a copy of the software and accompanying documentation (the 
 ** "Software") to use, reproduce, display, distribute, sub-license, execute, 
 ** and transmit the Software, and to prepare derivative works of the Software, 
 ** and to permit third-parties to whom the Software is furnished to do so, in 
 ** accordance with:
 ** 
 ** (1) if the Software is obtained from Blackmagic Design, the End User License 
 ** Agreement for the Software Development Kit (“EULA”) available at 
 ** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
 ** 
 ** (2) if the Software is obtained from any third party, such licensing terms 
 ** as notified by that third party,
 ** 
 ** and all subject to the following:
 ** 
 ** (3) the copyright notices in the Software and this entire statement, 
 ** including the above license grant, this restriction and the following 
 ** disclaimer, must be included in all copies of the Software, in whole or in 
 ** part, and all derivative works of the Software, unless such copies or 
 ** derivative works are solely in the form of machine-executable object code 
 ** generated by a source language processor.
 ** 
 ** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 ** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 ** DEALINGS IN THE SOFTWARE.
 ** 
 ** A copy of the Software is available free of charge at 
 ** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
 ** 
 ** -LICENSE-END-
 */

#import "CapturePreview.h"
#import "DeckLinkInputDevice.h"

/// DeckLinkInputCallback implementation

DeckLinkInputCallback::DeckLinkInputCallback() :
	m_videoFormatChangedHandler(nullptr),
	m_videoFrameArrivedHandler(nullptr),
	m_refCount(1)
{
}

HRESULT DeckLinkInputCallback::QueryInterface(REFIID iid, LPVOID *ppv)
{
	HRESULT result = S_OK;
	
	if (ppv == nullptr)
		return E_POINTER;
	
	// Obtain the IUnknown interface and compare it the provided REFIID
	CFUUIDBytes iunknown = CFUUIDGetUUIDBytes(IUnknownUUID);
	if (memcmp(&iid, &iunknown, sizeof(REFIID)) == 0)
	{
		*ppv = this;
		AddRef();
	}
	else if (memcmp(&iid, &IID_IDeckLinkInputCallback, sizeof(REFIID)) == 0)
	{
		*ppv = static_cast<IDeckLinkInputCallback*>(this);
		AddRef();
	}
	else
	{
		*ppv = nullptr;
		result = E_NOINTERFACE;
	}
	
	return result;
}

ULONG DeckLinkInputCallback::AddRef(void)
{
	return ++m_refCount;
}

ULONG DeckLinkInputCallback::Release(void)
{
	ULONG newRefValue = --m_refCount;
	if (newRefValue == 0)
		delete this;
	
	return newRefValue;
}

HRESULT DeckLinkInputCallback::VideoInputFormatChanged(BMDVideoInputFormatChangedEvents notificationEvents, IDeckLinkDisplayMode *newMode, BMDDetectedVideoInputFormatFlags detectedSignalFlags)
{
	if (m_videoFormatChangedHandler)
		m_videoFormatChangedHandler(notificationEvents, com_ptr<IDeckLinkDisplayMode>(newMode), detectedSignalFlags);

	return S_OK;
}

HRESULT DeckLinkInputCallback::VideoInputFrameArrived(IDeckLinkVideoInputFrame* videoFrame, IDeckLinkAudioInputPacket* audioPacket)
{
	if (m_videoFrameArrivedHandler)
		m_videoFrameArrivedHandler(com_ptr<IDeckLinkVideoInputFrame>(videoFrame));

	return S_OK;
}


/// DeckLinkDevice private members and methods

@interface DeckLinkInputDevice()

@property (assign) CapturePreviewAppDelegate*              uiDelegate;
@property (assign) com_ptr<IDeckLinkInput>                 deckLinkInput;
@property (assign) com_ptr<IDeckLinkConfiguration>         deckLinkConfig;
@property (assign) com_ptr<IDeckLinkHDMIInputEDID>         deckLinkHDMIInputEDID;
@property (assign) com_ptr<DeckLinkInputCallback>          callbackDelegate;

- (void)handleVideoInputFormatChange:(com_ptr<IDeckLinkDisplayMode>&)newMode
				  notificationEvents:(BMDVideoInputFormatChangedEvents) notificationEvents
				 detectedSignalFlags:(BMDDetectedVideoInputFormatFlags)detectedSignalFlags;
- (void)handleReceivedVideoInputFrame:(com_ptr<IDeckLinkVideoInputFrame>&)videoFrame;
- (TimecodeStruct*)getTimecodeFromFrame:(com_ptr<IDeckLinkVideoInputFrame>&)videoFrame withFormat:(BMDTimecodeFormat)timecodeFormat;
- (MetadataStruct*)getMetadataFromFrame:(com_ptr<IDeckLinkVideoInputFrame>&)videoFrame;

@end

/// DeckLinkDevice implementation

@implementation DeckLinkInputDevice

@synthesize deckLink = _deckLink;
@synthesize isCapturing = _isCapturing;

- (instancetype)initWithDeckLink:(const com_ptr<IDeckLink>&)deckLink uiDelegate:(CapturePreviewAppDelegate*)uiDelegate
{
	self = [super init];
	if (self)
	{
		_uiDelegate = uiDelegate;
		
		_deckLink = deckLink;
		_deckLinkInput = com_ptr<IDeckLinkInput>(IID_IDeckLinkInput, deckLink);
		_deckLinkConfig = com_ptr<IDeckLinkConfiguration>(IID_IDeckLinkConfiguration, deckLink);
		if (!_deckLinkInput || !_deckLinkConfig)
		{
			[super dealloc];
			return nil;
		}
		
		// Enable all EDID functionality if possible
		_deckLinkHDMIInputEDID = com_ptr<IDeckLinkHDMIInputEDID>(IID_IDeckLinkHDMIInputEDID, deckLink);
		if (_deckLinkHDMIInputEDID)
		{
			int64_t allKnownRanges = bmdDynamicRangeSDR | bmdDynamicRangeHDRStaticPQ | bmdDynamicRangeHDRStaticHLG;
			_deckLinkHDMIInputEDID->SetInt(bmdDeckLinkHDMIInputEDIDDynamicRange, allKnownRanges);
			_deckLinkHDMIInputEDID->WriteToEDID();
		}

		_callbackDelegate = make_com_ptr<DeckLinkInputCallback>();
		_callbackDelegate->setVideoFormatChangeHandler(^(BMDVideoInputFormatChangedEvents notificationEvents,
												 com_ptr<IDeckLinkDisplayMode> displayMode,
												 BMDDetectedVideoInputFormatFlags detectedSignalFlags) {
			[self handleVideoInputFormatChange:displayMode
							notificationEvents:notificationEvents
						   detectedSignalFlags:detectedSignalFlags];
		});
		_callbackDelegate->setVideoFrameArrivalHandler(^(com_ptr<IDeckLinkVideoInputFrame> videoFrame) {
			[self handleReceivedVideoInputFrame:videoFrame];
		});
		
		_isCapturing = NO;
	}
	return self;
}

- (BOOL)startCaptureWithDisplayMode:(BMDDisplayMode)displayMode screenPreviewCalback:(com_ptr<IDeckLinkScreenPreviewCallback>&) screenPreviewCallback applyDetectedInputMode:(BOOL)applyDetectedInputMode
{
	BMDVideoInputFlags		videoInputFlags;
	
	// Enable input video mode detection if the device supports it
	videoInputFlags = ([self supportsFormatDetection] && applyDetectedInputMode) ? bmdVideoInputEnableFormatDetection : bmdVideoInputFlagDefault;
	
	// Set the screen preview
	_deckLinkInput->SetScreenPreviewCallback(screenPreviewCallback.get());
	
	// Set capture callback
	_deckLinkInput->SetCallback(_callbackDelegate.get());
	
	// Set the video input mode
	if (_deckLinkInput->EnableVideoInput(displayMode, bmdFormat10BitYUV, videoInputFlags) != S_OK)
	{
		[_uiDelegate showErrorMessage:@"This application was unable to select the chosen video mode. Perhaps, the selected device is currently in-use." title:@"Error starting the capture"];
		return NO;
	}
	
	// Start the capture
	if (_deckLinkInput->StartStreams() != S_OK)
	{
		[_uiDelegate showErrorMessage:@"This application was unable to start the capture. Perhaps, the selected device is currently in-use." title:@"Error starting the capture"];
		return NO;
	}
	
	_isCapturing = YES;
	
	return YES;
}

- (void)stopCapture
{
	// Stop the capture
	_deckLinkInput->StopStreams();
	
	// Delete capture callback
	_deckLinkInput->SetCallback(NULL);
	_deckLinkInput->DisableVideoInput();
	
	_isCapturing = NO;
}

- (void)queryDisplayModesWithBlock:(const QueryDisplayModeBlock&)block
{
	com_ptr<IDeckLinkDisplayModeIterator>	displayModeIterator;
	com_ptr<IDeckLinkDisplayMode>			displayMode;

	if (block == nil)
		return;
	
	if (_deckLinkInput->GetDisplayModeIterator(displayModeIterator.releaseAndGetAddressOf()) != S_OK)
		return;

	while (displayModeIterator->Next(displayMode.releaseAndGetAddressOf()) == S_OK)
	{
		BMDDisplayMode bmdDisplayMode = displayMode->GetDisplayMode();
		HRESULT hr;
		CFStringRef displayModeCFString;
		bool supported;
		
		hr = _deckLinkInput->DoesSupportVideoMode(currentVideoInputConnection, bmdDisplayMode, bmdFormatUnspecified,
												  bmdNoVideoInputConversion, bmdSupportedVideoModeDefault, nullptr, &supported);
		if (hr != S_OK || !supported)
			continue;
		
		hr = displayMode->GetName(&displayModeCFString);
		if (hr != S_OK)
			continue;
		
		NSString* displayModeName = [NSString stringWithString: (NSString *)displayModeCFString];
		CFRelease(displayModeCFString);

		block(bmdDisplayMode, displayModeName);
	}
}

- (void)handleVideoInputFormatChange:(com_ptr<IDeckLinkDisplayMode>&)newMode
				  notificationEvents:(BMDVideoInputFormatChangedEvents)notificationEvents
				 detectedSignalFlags:(BMDDetectedVideoInputFormatFlags)detectedSignalFlags
{
	uint32_t			flags = bmdVideoInputEnableFormatDetection;
	BMDPixelFormat		pixelFormat;

	BMDDisplayMode newDisplayMode = newMode->GetDisplayMode();

	if (detectedSignalFlags & bmdDetectedVideoInputRGB444)
	{
		if (detectedSignalFlags & bmdDetectedVideoInput8BitDepth)
			pixelFormat = bmdFormat8BitARGB;
		else if (detectedSignalFlags & bmdDetectedVideoInput10BitDepth)
			pixelFormat = bmdFormat10BitRGB;
		else if (detectedSignalFlags & bmdDetectedVideoInput12BitDepth)
			pixelFormat = bmdFormat12BitRGB;
		else
			// Invalid color depth for RGB
			return;
	}
	else if (detectedSignalFlags & bmdDetectedVideoInputYCbCr422)
	{
		if (detectedSignalFlags & bmdDetectedVideoInput8BitDepth)
			pixelFormat = bmdFormat8BitYUV;
		else if (detectedSignalFlags & bmdDetectedVideoInput10BitDepth)
			pixelFormat = bmdFormat10BitYUV;
		else
			// Invalid color depth for YUV
			return;
	}
	else
		// Unexpected detected signal flag
		return;

	if (detectedSignalFlags & bmdDetectedVideoInputDualStream3D)
		flags |= bmdVideoInputDualStream3D;

	// Restart capture with the new video mode if told to
	if (([_uiDelegate shouldRestartCaptureWithNewVideoMode] == YES) &&
		(notificationEvents & (bmdVideoInputDisplayModeChanged | bmdVideoInputColorspaceChanged)))
	{
		// Stop the capture
		_deckLinkInput->StopStreams();
		
		// Set the video input mode
		if (_deckLinkInput->EnableVideoInput(newMode->GetDisplayMode(), pixelFormat, flags) != S_OK)
		{
			[self notifyCaptureRestartError:@"This application was unable to select the new video mode."];
			return;
		}
		
		// Start the capture
		if (_deckLinkInput->StartStreams() != S_OK)
		{
			[self notifyCaptureRestartError:@"This application was unable to start the capture on the selected device."];
			return;
		}
	}
	
	// Update the UI with detected display mode
	dispatch_async(dispatch_get_main_queue(), ^{
		[_uiDelegate selectDetectedVideoMode:newDisplayMode];
	});
}

- (void)notifyCaptureRestartError:(NSString*)message
{
	dispatch_async(dispatch_get_main_queue(), ^{
		[_uiDelegate stopCapture];
		[_uiDelegate showErrorMessage:message title:@"Error restarting the capture."];
	});
}

- (void)handleReceivedVideoInputFrame:(com_ptr<IDeckLinkVideoInputFrame>&)videoFrame
{
	BOOL							hasValidInputSource = (videoFrame->GetFlags() & bmdFrameHasNoInputSource) != 0 ? NO : YES;
	NSAutoreleasePool* 				pool = [[NSAutoreleasePool alloc] init];
	AncillaryDataStruct*			ancillaryData = [[[AncillaryDataStruct alloc] init] autorelease];
	
	// Get the various timecodes and userbits for this frame
	ancillaryData.vitcF1 = [self getTimecodeFromFrame:videoFrame withFormat:bmdTimecodeVITC];
	ancillaryData.vitcF2 = [self getTimecodeFromFrame:videoFrame withFormat:bmdTimecodeVITCField2];
	ancillaryData.rp188vitc1 = [self getTimecodeFromFrame:videoFrame withFormat:bmdTimecodeRP188VITC1];
	ancillaryData.rp188ltc = [self getTimecodeFromFrame:videoFrame withFormat:bmdTimecodeRP188LTC];
	ancillaryData.rp188vitc2 = [self getTimecodeFromFrame:videoFrame withFormat:bmdTimecodeRP188VITC2];
	ancillaryData.rp188hfrtc = [self getTimecodeFromFrame:videoFrame withFormat:bmdTimecodeRP188HighFrameRate];
	ancillaryData.metadata = [self getMetadataFromFrame:videoFrame];

	// Update the UI
	dispatch_block_t updateAncillary = ^{
		// Update input source label
		[_uiDelegate updateInputSourceState:hasValidInputSource];
		
		// Update ancillary table
		[_uiDelegate setAncillaryData:ancillaryData];
		[_uiDelegate reloadAncillaryTable];
	};
	
	dispatch_async(dispatch_get_main_queue(), updateAncillary);

	[pool release];
}

- (TimecodeStruct*)getTimecodeFromFrame:(com_ptr<IDeckLinkVideoInputFrame>&)videoFrame withFormat:(BMDTimecodeFormat)timecodeFormat;
{
	com_ptr<IDeckLinkTimecode>		timecode;
	CFStringRef						timecodeCFString;
	BMDTimecodeUserBits				userBits = 0;
	TimecodeStruct*					returnTimeCode = [[[TimecodeStruct alloc] init] autorelease];
	
	if (videoFrame && videoFrame->GetTimecode(timecodeFormat, timecode.releaseAndGetAddressOf()) == S_OK)
	{
		if (timecode->GetString(&timecodeCFString) == S_OK)
		{
			returnTimeCode.timecode = [NSString stringWithString: (NSString *)timecodeCFString];
			CFRelease(timecodeCFString);
		}
		else
		{
			returnTimeCode.timecode = @"";
		}
		
		timecode->GetTimecodeUserBits(&userBits);
		returnTimeCode.userBits = [NSString stringWithFormat:@"0x%08X", userBits];
	}
	else
	{
		returnTimeCode.timecode = @"";
		returnTimeCode.userBits = @"";
	}
	
	return returnTimeCode;
}

- (MetadataStruct*)getMetadataFromFrame:(com_ptr<IDeckLinkVideoInputFrame>&)frame
{
	MetadataStruct* returnMetadata = [[[MetadataStruct alloc] init] autorelease];

	returnMetadata.electroOpticalTransferFunction = @"";
	returnMetadata.displayPrimariesRedX = @"";
	returnMetadata.displayPrimariesRedY = @"";
	returnMetadata.displayPrimariesGreenX = @"";
	returnMetadata.displayPrimariesGreenY = @"";
	returnMetadata.displayPrimariesBlueX = @"";
	returnMetadata.displayPrimariesBlueY = @"";
	returnMetadata.whitePointX = @"";
	returnMetadata.whitePointY = @"";
	returnMetadata.maxDisplayMasteringLuminance = @"";
	returnMetadata.minDisplayMasteringLuminance = @"";
	returnMetadata.maximumContentLightLevel = @"";
	returnMetadata.maximumFrameAverageLightLevel = @"";
	returnMetadata.colorspace = @"";

	com_ptr<IDeckLinkVideoFrameMetadataExtensions> metadataExtensions;
	if (frame->QueryInterface(IID_IDeckLinkVideoFrameMetadataExtensions, (void**)metadataExtensions.releaseAndGetAddressOf()) == S_OK)
	{
		double doubleValue = 0.0;
		int64_t intValue = 0;

		if (metadataExtensions->GetInt(bmdDeckLinkFrameMetadataHDRElectroOpticalTransferFunc, &intValue) == S_OK)
		{
			switch (intValue)
			{
				case 0:
					returnMetadata.electroOpticalTransferFunction = [NSString stringWithFormat:@"SDR"];
					break;
				case 1:
					returnMetadata.electroOpticalTransferFunction = [NSString stringWithFormat:@"HDR"];
					break;
				case 2:
					returnMetadata.electroOpticalTransferFunction = [NSString stringWithFormat:@"PQ (ST2084)"];
					break;
				case 3:
					returnMetadata.electroOpticalTransferFunction = [NSString stringWithFormat:@"HLG"];
					break;
				default:
					returnMetadata.electroOpticalTransferFunction = [NSString stringWithFormat:@"Unknown EOTF: %d", (int32_t)intValue];
					break;
			}
		}

		if (frame->GetFlags() & bmdFrameContainsHDRMetadata)
		{
			if (metadataExtensions->GetFloat(bmdDeckLinkFrameMetadataHDRDisplayPrimariesRedX, &doubleValue) == S_OK)
				returnMetadata.displayPrimariesRedX = [NSString stringWithFormat:@"%.04f", doubleValue];

			if (metadataExtensions->GetFloat(bmdDeckLinkFrameMetadataHDRDisplayPrimariesRedY, &doubleValue) == S_OK)
				returnMetadata.displayPrimariesRedY = [NSString stringWithFormat:@"%.04f", doubleValue];

			if (metadataExtensions->GetFloat(bmdDeckLinkFrameMetadataHDRDisplayPrimariesGreenX, &doubleValue) == S_OK)
				returnMetadata.displayPrimariesGreenX = [NSString stringWithFormat:@"%.04f", doubleValue];

			if (metadataExtensions->GetFloat(bmdDeckLinkFrameMetadataHDRDisplayPrimariesGreenY, &doubleValue) == S_OK)
				returnMetadata.displayPrimariesGreenY = [NSString stringWithFormat:@"%.04f", doubleValue];

			if (metadataExtensions->GetFloat(bmdDeckLinkFrameMetadataHDRDisplayPrimariesBlueX, &doubleValue) == S_OK)
				returnMetadata.displayPrimariesBlueX = [NSString stringWithFormat:@"%.04f", doubleValue];

			if (metadataExtensions->GetFloat(bmdDeckLinkFrameMetadataHDRDisplayPrimariesBlueY, &doubleValue) == S_OK)
				returnMetadata.displayPrimariesBlueY = [NSString stringWithFormat:@"%.04f", doubleValue];

			if (metadataExtensions->GetFloat(bmdDeckLinkFrameMetadataHDRWhitePointX, &doubleValue) == S_OK)
				returnMetadata.whitePointX = [NSString stringWithFormat:@"%.04f", doubleValue];

			if (metadataExtensions->GetFloat(bmdDeckLinkFrameMetadataHDRWhitePointY, &doubleValue) == S_OK)
				returnMetadata.whitePointY = [NSString stringWithFormat:@"%.04f", doubleValue];

			if (metadataExtensions->GetFloat(bmdDeckLinkFrameMetadataHDRMaxDisplayMasteringLuminance, &doubleValue) == S_OK)
				returnMetadata.maxDisplayMasteringLuminance = [NSString stringWithFormat:@"%.04f", doubleValue];

			if (metadataExtensions->GetFloat(bmdDeckLinkFrameMetadataHDRMinDisplayMasteringLuminance, &doubleValue) == S_OK)
				returnMetadata.minDisplayMasteringLuminance = [NSString stringWithFormat:@"%.04f", doubleValue];

			if (metadataExtensions->GetFloat(bmdDeckLinkFrameMetadataHDRMaximumContentLightLevel, &doubleValue) == S_OK)
				returnMetadata.maximumContentLightLevel = [NSString stringWithFormat:@"%.04f", doubleValue];

			if (metadataExtensions->GetFloat(bmdDeckLinkFrameMetadataHDRMaximumFrameAverageLightLevel, &doubleValue) == S_OK)
				returnMetadata.maximumFrameAverageLightLevel = [NSString stringWithFormat:@"%.04f", doubleValue];
		}

		if (metadataExtensions->GetInt(bmdDeckLinkFrameMetadataColorspace, &intValue) == S_OK)
		{
			switch (intValue)
			{
				case bmdColorspaceRec601:
					returnMetadata.colorspace = [NSString stringWithFormat:@"Rec.601"];
					break;

				case bmdColorspaceRec709:
					returnMetadata.colorspace = [NSString stringWithFormat:@"Rec.709"];
					break;

				case bmdColorspaceRec2020:
					returnMetadata.colorspace = [NSString stringWithFormat:@"Rec.2020"];
					break;
			}
		}
	}
	return returnMetadata;
}

- (BOOL)supportsFormatDetection
{
	com_ptr<IDeckLinkProfileAttributes> deckLinkAttributes(IID_IDeckLinkProfileAttributes, _deckLink);
	bool attributeFlag;
	
	// Check if input mode detection format is supported.
	if (deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &attributeFlag) != S_OK)
		return NO;
	
	return attributeFlag ? YES : NO;
}

- (BOOL)isActive
{
	com_ptr<IDeckLinkProfileAttributes> deckLinkAttributes(IID_IDeckLinkProfileAttributes, _deckLink);
	int64_t intAttribute;

	if (!deckLinkAttributes)
		return false;

	if (deckLinkAttributes->GetInt(BMDDeckLinkDuplex, &intAttribute) != S_OK)
		return false;

	return ((BMDDuplexMode) intAttribute) != bmdDuplexInactive;
}

- (NSString*)deviceName
{
	CFStringRef displayNameCFString;
	NSString* displayName;
	
	if (_deckLink->GetDisplayName(&displayNameCFString) == S_OK)
	{
		displayName = [NSString stringWithString:(NSString*)displayNameCFString];
		CFRelease(displayNameCFString);
	}
	else
	{
		displayName = @"DeckLink";
	}

	return displayName;
}

- (BMDVideoConnection)supportedVideoInputConnections
{
	com_ptr<IDeckLinkProfileAttributes> deckLinkAttributes(IID_IDeckLinkProfileAttributes, _deckLink);
	int64_t intAttribute;

	if (!deckLinkAttributes)
		return (BMDVideoConnection)0;
	
	// Get the supported video input connections for the device
	if (deckLinkAttributes->GetInt(BMDDeckLinkVideoInputConnections, &intAttribute) != S_OK)
		return (BMDVideoConnection)0;

	return (BMDVideoConnection)intAttribute;
}

- (BMDVideoConnection)currentVideoInputConnection
{
	int64_t inputConnection;
	if (_deckLinkConfig->GetInt(bmdDeckLinkConfigVideoInputConnection, &inputConnection) != S_OK)
		inputConnection = 0;
	
	return (BMDVideoConnection)inputConnection;
}
																								  
- (void)setCurrentVideoInputConnection:(BMDVideoConnection)inputConnection
{
	(void)_deckLinkConfig->SetInt(bmdDeckLinkConfigVideoInputConnection, (int64_t)inputConnection);
}

@end
