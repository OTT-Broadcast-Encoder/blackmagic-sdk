/* -LICENSE-START-
 ** Copyright (c) 2011 Blackmagic Design
 **  
 ** Permission is hereby granted, free of charge, to any person or organization 
 ** obtaining a copy of the software and accompanying documentation (the 
 ** "Software") to use, reproduce, display, distribute, sub-license, execute, 
 ** and transmit the Software, and to prepare derivative works of the Software, 
 ** and to permit third-parties to whom the Software is furnished to do so, in 
 ** accordance with:
 ** 
 ** (1) if the Software is obtained from Blackmagic Design, the End User License 
 ** Agreement for the Software Development Kit (“EULA”) available at 
 ** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
 ** 
 ** (2) if the Software is obtained from any third party, such licensing terms 
 ** as notified by that third party,
 ** 
 ** and all subject to the following:
 ** 
 ** (3) the copyright notices in the Software and this entire statement, 
 ** including the above license grant, this restriction and the following 
 ** disclaimer, must be included in all copies of the Software, in whole or in 
 ** part, and all derivative works of the Software, unless such copies or 
 ** derivative works are solely in the form of machine-executable object code 
 ** generated by a source language processor.
 ** 
 ** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 ** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 ** DEALINGS IN THE SOFTWARE.
 ** 
 ** A copy of the Software is available free of charge at 
 ** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
 ** 
 ** -LICENSE-END-
 */

#import "CapturePreview.h"
#import "DeckLinkInputDevice.h"

using namespace std;

static const NSDictionary* kInputConnections = @{
												 [NSNumber numberWithInteger:bmdVideoConnectionSDI]				: @"SDI",
												 [NSNumber numberWithInteger:bmdVideoConnectionHDMI]			: @"HDMI",
												 [NSNumber numberWithInteger:bmdVideoConnectionOpticalSDI]		: @"Optical SDI",
												 [NSNumber numberWithInteger:bmdVideoConnectionComponent]		: @"Component",
												 [NSNumber numberWithInteger:bmdVideoConnectionComposite]		: @"Composite",
												 [NSNumber numberWithInteger:bmdVideoConnectionSVideo]			: @"S-Video",
												 [NSNumber numberWithInteger:bmdVideoConnectionEthernet]		: @"Ethernet",
												 [NSNumber numberWithInteger:bmdVideoConnectionOpticalEthernet]	: @"Optical Ethernet",
												};

@implementation TimecodeStruct
@synthesize timecode;
@synthesize userBits;

- (void)dealloc;
{
	[timecode release];
	[userBits release];
	
	[super dealloc];
}

-(id) copyWithZone: (NSZone *) zone
{
	TimecodeStruct *timecodeCopy = [[[self class] allocWithZone: zone] init];
	
	timecodeCopy.timecode = [NSString stringWithString:self.timecode];
	timecodeCopy.userBits = [NSString stringWithString:self.userBits];

	return timecodeCopy;
}

@end

@implementation AncillaryDataStruct

@synthesize vitcF1;
@synthesize vitcF2;
@synthesize rp188vitc1;
@synthesize rp188vitc2;
@synthesize rp188ltc;
@synthesize rp188hfrtc;
@synthesize metadata;

- (void)dealloc
{
	[vitcF1 dealloc];
	[vitcF2 dealloc];
	[rp188vitc1 dealloc];
	[rp188vitc2 dealloc];
	[rp188ltc dealloc];
	[rp188hfrtc dealloc];
	[metadata dealloc];
	
	[super dealloc];
}
@end

@implementation MetadataStruct
@synthesize electroOpticalTransferFunction;
@synthesize displayPrimariesRedX;
@synthesize displayPrimariesRedY;
@synthesize displayPrimariesGreenX;
@synthesize displayPrimariesGreenY;
@synthesize displayPrimariesBlueX;
@synthesize displayPrimariesBlueY;
@synthesize whitePointX;
@synthesize whitePointY;
@synthesize maxDisplayMasteringLuminance;
@synthesize minDisplayMasteringLuminance;
@synthesize maximumContentLightLevel;
@synthesize maximumFrameAverageLightLevel;
@synthesize colorspace;

- (void)dealloc;
{
	[electroOpticalTransferFunction release];
	[displayPrimariesRedX release];
	[displayPrimariesRedY release];
	[displayPrimariesGreenX release];
	[displayPrimariesGreenY release];
	[displayPrimariesBlueX release];
	[displayPrimariesBlueY release];
	[whitePointX release];
	[whitePointY release];
	[maxDisplayMasteringLuminance release];
	[minDisplayMasteringLuminance release];
	[maximumContentLightLevel release];
	[maximumFrameAverageLightLevel release];
	[colorspace release];

	[super dealloc];
}

-(id) copyWithZone: (NSZone *) zone
{
	MetadataStruct *metadataCopy = [[[self class] allocWithZone: zone] init];

	metadataCopy.electroOpticalTransferFunction = [NSString stringWithString:self.electroOpticalTransferFunction];
	metadataCopy.displayPrimariesRedX = [NSString stringWithString:self.displayPrimariesRedX];
	metadataCopy.displayPrimariesRedY = [NSString stringWithString:self.displayPrimariesRedY];
	metadataCopy.displayPrimariesGreenX = [NSString stringWithString:self.displayPrimariesGreenX];
	metadataCopy.displayPrimariesGreenY = [NSString stringWithString:self.displayPrimariesGreenY];
	metadataCopy.displayPrimariesBlueX = [NSString stringWithString:self.displayPrimariesBlueX];
	metadataCopy.displayPrimariesBlueY = [NSString stringWithString:self.displayPrimariesBlueY];
	metadataCopy.whitePointX = [NSString stringWithString:self.whitePointX];
	metadataCopy.whitePointY = [NSString stringWithString:self.whitePointY];
	metadataCopy.maxDisplayMasteringLuminance = [NSString stringWithString:self.maxDisplayMasteringLuminance];
	metadataCopy.minDisplayMasteringLuminance = [NSString stringWithString:self.minDisplayMasteringLuminance];
	metadataCopy.maximumContentLightLevel = [NSString stringWithString:self.maximumContentLightLevel];
	metadataCopy.maximumFrameAverageLightLevel = [NSString stringWithString:self.maximumFrameAverageLightLevel];
	metadataCopy.colorspace = [NSString stringWithString:self.colorspace];

	return metadataCopy;
}
@end


@implementation CapturePreviewAppDelegate

@synthesize window;
@synthesize ancillaryDataValues;

- (id)init
{
	self = [super init];
	if (self)
	{
		ancillaryDataValues = [[NSMutableArray arrayWithObjects:@"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", @"", nil] retain];
		ancillaryDataTypes = [[NSMutableArray arrayWithObjects:
							@"VITC Timecode field 1", 
							@"VITC User bits field 1", 
							@"VITC Timecode field 2", 
							@"VITC User bits field 2", 
							@"RP188 VITC1 Timecode", 
							@"RP188 VITC1 User bits",
							@"RP188 LTC Timecode", 
							@"RP188 LTC User bits",
							@"RP188 VITC2 Timecode", 
							@"RP188 VITC2 User bits",
							@"RP188 HFRTC Timecode",
							@"RP188 HFRTC User bits",
							@"Static HDR Electro-optical Transfer Function",
							@"Static HDR Display Primaries Red X",
							@"Static HDR Display Primaries Red Y",
							@"Static HDR Display Primaries Green X",
							@"Static HDR Display Primaries Green Y",
							@"Static HDR Display Primaries Blue X",
							@"Static HDR Display Primaries Blue Y",
							@"Static HDR White Point X",
							@"Static HDR White Point Y",
							@"Static HDR Max Display Mastering Luminance",
							@"Static HDR Min Display Mastering Luminance",
							@"Static HDR Max Content Light Level",
							@"Static HDR Max Frame Average Light Level",
							@"Colorspace",
							nil] retain];
	}
	return self;
}

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification
{
	//
	// Setup UI
	
	// Empty popup menus
	[deviceListPopup removeAllItems];
	[modeListPopup removeAllItems];
	[ancillaryDataTable reloadData];
	
	// Set device list popup for manual enabling, so we can disable inactive devices
	[deviceListPopup setAutoenablesItems:NO];

	// Disable the interface
	[startStopButton setEnabled:NO];
	[self enableInterface:NO];
	
	//
	// Create and initialise DeckLink device discovery, profile manager and preview objects
	screenPreviewCallback = CreateCocoaScreenPreview(previewView);
	deckLinkDiscovery = [[DeckLinkDeviceDiscovery alloc] initWithUIDelegate:self];
	if (screenPreviewCallback && deckLinkDiscovery != nil)
	{
		[deckLinkDiscovery enable];
	}
	else
	{
		[self showErrorMessage:@"This application requires the Desktop Video drivers installed." title:@"Please install the Blackmagic Desktop Video drivers to use the features of this application."];
	}
	
}

- (void)addDevice:(const com_ptr<IDeckLink>&)deckLink
{
	// Create new DeckLinkDevice object to wrap around new IDeckLink instance
	DeckLinkInputDevice* device = [[DeckLinkInputDevice alloc] initWithDeckLink:deckLink uiDelegate:self];
	
	// Initialise new DeckLinkDevice object
	if (!device)
	{
		[self showErrorMessage:@"Error initialising the new device" title:@"This application is unable to initialise the new device"];
		return;
	}
	
	[[deviceListPopup menu] addItemWithTitle:[device deviceName] action:nil keyEquivalent:@""];
	[[deviceListPopup lastItem] setTag:(NSInteger)device];
	[[deviceListPopup lastItem] setEnabled:[device isActive]];

	if ([deviceListPopup numberOfItems] == 1)
	{
		// We have added our first item, enable the interface
		[deviceListPopup selectItemAtIndex:0];
		[self newDeviceSelected:nil];
		[self enableInterface:YES];
	}
}

- (void)removeDevice:(const com_ptr<IDeckLink>&)deckLink
{
	DeckLinkInputDevice* deviceToRemove = NULL;
	DeckLinkInputDevice* removalCandidate = NULL;
	NSInteger index = 0;
	
	// Find the DeckLinkDevice that wraps the IDeckLink being removed
	for (NSMenuItem* item in [deviceListPopup itemArray])
	{
		removalCandidate = (DeckLinkInputDevice*)[item tag];

		if ([removalCandidate deckLink].get() == deckLink.get())
		{
			deviceToRemove = removalCandidate;
			break;
		}
		++index;
	}
	
	if (deviceToRemove == NULL)
		return;
	
	// If capture is ongoing, stop it
	if ([deviceToRemove isCapturing])
		[deviceToRemove stopCapture];
	
	[deviceListPopup removeItemAtIndex:index];
	
	[startStopButton setTitle:@"Start Capture"];
	
	if ([deviceListPopup numberOfItems] == 0)
	{
		// We have removed the last item, disable the interface
		[startStopButton setEnabled:NO];
		[self enableInterface:NO];
		selectedDevice = NULL;
	}
	else if (selectedDevice == deviceToRemove)
	{
		// Select the first device in the list and enable the interface
		[deviceListPopup selectItemAtIndex:0];
		[self newDeviceSelected:nil];
	}
	
	// Release DeckLinkDevice instance
	deviceToRemove = nullptr;
}

- (void)showErrorMessage:(NSString*)message title:(NSString*)title
{
	NSAlert* alert = [[NSAlert alloc] init];
	alert.messageText = title;
	alert.informativeText = message;
	[alert runModal];
	[alert release];
}

- (void)refreshInputConnectionList
{
	BMDVideoConnection availableInputConnections = [selectedDevice supportedVideoInputConnections];
	
	[inputConnectionPopup removeAllItems];
	
	for (NSNumber* key in kInputConnections)
	{
		BMDVideoConnection inputConnection = (BMDVideoConnection)[key intValue];
		
		if ((inputConnection & availableInputConnections) != 0)
		{
			[inputConnectionPopup addItemWithTitle:kInputConnections[key]];
			[[inputConnectionPopup lastItem] setTag:(NSInteger)inputConnection];
		}
	}

	if ([inputConnectionPopup numberOfItems] > 0)
	{
		BMDVideoConnection currentInputConnection = [selectedDevice currentVideoInputConnection];
		
		// Get the current selected input connection
		if (currentInputConnection != 0)
		{
			[inputConnectionPopup selectItemWithTag:(NSInteger)currentInputConnection];
			[self newConnectionSelected:nil];
		}
	}
}

- (void)refreshVideoModeList
{
	// Clear the menu
	[modeListPopup removeAllItems];
	
	[selectedDevice queryDisplayModesWithBlock:(^(BMDDisplayMode displayMode, NSString* displayModeString) {
		// Add this item to the video format poup menu
		[modeListPopup addItemWithTitle:displayModeString];
		
		// Save the BMDDisplayMode in the menu item's tag
		[[modeListPopup lastItem] setTag:(NSInteger)displayMode];
	})];
	
	[startStopButton setEnabled:([modeListPopup numberOfItems] != 0)];
}

- (IBAction)newDeviceSelected:(id)sender
{
	// Get the DeckLinkDevice object for the selected menu item.
	selectedDevice = (DeckLinkInputDevice*)[[deviceListPopup selectedItem] tag];
	
	if (selectedDevice == nil)
		return;

	// Update the input connections popup menu
	[self refreshInputConnectionList];
				
	// Set default state for apply detected video mode checkbox
	[applyDetectedVideoMode setState:([selectedDevice supportsFormatDetection] ? NSControlStateValueOn : NSControlStateValueOff)];
	[self toggleApplyDetectionVideoMode:nil];
}


- (IBAction)newConnectionSelected:(id)sender
{
	selectedInputConnection = (BMDVideoConnection)[[inputConnectionPopup selectedItem] tag];
	
	// Configure input connection for selected device
	[selectedDevice setCurrentVideoInputConnection:selectedInputConnection];
	
	// Updated video mode popup for selected input connection
	[self refreshVideoModeList];
}

- (IBAction)toggleStart:(id)sender
{
	if (selectedDevice == nil)
		return;
	
	if ([selectedDevice isCapturing])
		[self stopCapture];
	else
		[self startCapture];
}

- (IBAction)toggleApplyDetectionVideoMode:(id)sender
{
	[modeListPopup setEnabled:([applyDetectedVideoMode state] == NSControlStateValueOff)];
}

- (void)startCapture
{
	if (selectedDevice &&
		[selectedDevice startCaptureWithDisplayMode:[[modeListPopup selectedItem] tag]
							   screenPreviewCalback:screenPreviewCallback
							 applyDetectedInputMode:([applyDetectedVideoMode state] == NSControlStateValueOn)])
	{
		// Update UI
		[startStopButton setTitle:@"Stop"];
		[self enableInterface: NO];
	}
}

- (void)stopCapture
{
	if (selectedDevice != nil)
		[selectedDevice stopCapture];
	
	// Update UI
	[startStopButton setTitle:@"Start Capture"];
	[self enableInterface:YES];
	[noValidSource setHidden:YES];
	
}

- (void)enableInterface:(BOOL)enabled
{
	[deviceListPopup setEnabled:enabled];
	[inputConnectionPopup setEnabled:enabled];
	[noValidSource setHidden:YES];
	
	if (enabled)
	{
		[applyDetectedVideoMode setEnabled:(selectedDevice && [selectedDevice supportsFormatDetection])];
		[modeListPopup setEnabled:([applyDetectedVideoMode state] == NSControlStateValueOff)];
	}
	else
	{
		[applyDetectedVideoMode setEnabled:NO];
		[modeListPopup setEnabled:enabled];
	}
}

- (BOOL)shouldRestartCaptureWithNewVideoMode
{
	__block NSControlStateValue state;
	dispatch_sync(dispatch_get_main_queue(), ^{ state = [applyDetectedVideoMode state];});
	return (state == NSControlStateValueOn) ? YES : NO;
}

- (void)updateInputSourceState:(BOOL)state
{
	// Check if the state has changed
	if ([noValidSource isHidden] != state)
	{
		[noValidSource setHidden:state];
	}
}

- (void)selectDetectedVideoMode:(BMDDisplayMode)newVideoMode
{
	[modeListPopup selectItemWithTag:(NSInteger)newVideoMode];
}

- (void)setAncillaryData:(AncillaryDataStruct *)latestAncillaryDataValues
{
	// VITC
	[ancillaryDataValues replaceObjectAtIndex:0 withObject:latestAncillaryDataValues.vitcF1.timecode];
	[ancillaryDataValues replaceObjectAtIndex:1 withObject:latestAncillaryDataValues.vitcF1.userBits];
	[ancillaryDataValues replaceObjectAtIndex:2 withObject:latestAncillaryDataValues.vitcF2.timecode];
	[ancillaryDataValues replaceObjectAtIndex:3 withObject:latestAncillaryDataValues.vitcF2.userBits];
	
	// RP188
	[ancillaryDataValues replaceObjectAtIndex:4 withObject:latestAncillaryDataValues.rp188vitc1.timecode];
	[ancillaryDataValues replaceObjectAtIndex:5 withObject:latestAncillaryDataValues.rp188vitc1.userBits];
	[ancillaryDataValues replaceObjectAtIndex:6 withObject:latestAncillaryDataValues.rp188ltc.timecode];
	[ancillaryDataValues replaceObjectAtIndex:7 withObject:latestAncillaryDataValues.rp188ltc.userBits];
	[ancillaryDataValues replaceObjectAtIndex:8 withObject:latestAncillaryDataValues.rp188vitc2.timecode];
	[ancillaryDataValues replaceObjectAtIndex:9 withObject:latestAncillaryDataValues.rp188vitc2.userBits];
	[ancillaryDataValues replaceObjectAtIndex:10 withObject:latestAncillaryDataValues.rp188hfrtc.timecode];
	[ancillaryDataValues replaceObjectAtIndex:11 withObject:latestAncillaryDataValues.rp188hfrtc.userBits];

	// HDR metadata
	[ancillaryDataValues replaceObjectAtIndex:12 withObject:latestAncillaryDataValues.metadata.electroOpticalTransferFunction];
	[ancillaryDataValues replaceObjectAtIndex:13 withObject:latestAncillaryDataValues.metadata.displayPrimariesRedX];
	[ancillaryDataValues replaceObjectAtIndex:14 withObject:latestAncillaryDataValues.metadata.displayPrimariesRedY];
	[ancillaryDataValues replaceObjectAtIndex:15 withObject:latestAncillaryDataValues.metadata.displayPrimariesGreenX];
	[ancillaryDataValues replaceObjectAtIndex:16 withObject:latestAncillaryDataValues.metadata.displayPrimariesGreenY];
	[ancillaryDataValues replaceObjectAtIndex:17 withObject:latestAncillaryDataValues.metadata.displayPrimariesBlueX];
	[ancillaryDataValues replaceObjectAtIndex:18 withObject:latestAncillaryDataValues.metadata.displayPrimariesBlueY];
	[ancillaryDataValues replaceObjectAtIndex:19 withObject:latestAncillaryDataValues.metadata.whitePointX];
	[ancillaryDataValues replaceObjectAtIndex:20 withObject:latestAncillaryDataValues.metadata.whitePointY];
	[ancillaryDataValues replaceObjectAtIndex:21 withObject:latestAncillaryDataValues.metadata.maxDisplayMasteringLuminance];
	[ancillaryDataValues replaceObjectAtIndex:22 withObject:latestAncillaryDataValues.metadata.minDisplayMasteringLuminance];
	[ancillaryDataValues replaceObjectAtIndex:23 withObject:latestAncillaryDataValues.metadata.maximumContentLightLevel];
	[ancillaryDataValues replaceObjectAtIndex:24 withObject:latestAncillaryDataValues.metadata.maximumFrameAverageLightLevel];
	[ancillaryDataValues replaceObjectAtIndex:25 withObject:latestAncillaryDataValues.metadata.colorspace];
}

- (void)reloadAncillaryTable;
{
	[ancillaryDataTable reloadData];
}

- (id)tableView:(NSTableView *)aTableView objectValueForTableColumn:(NSTableColumn *)aTableColumn row:(NSInteger)rowIndex
{
	if (([aTableColumn identifier] != nil) && [[aTableColumn identifier] isEqualToString:@"Type"])
	{
		if (rowIndex >= [ancillaryDataTypes count])
			return @"unknown row";
		
		// return ancillary data labels
		return [ancillaryDataTypes objectAtIndex:rowIndex];
	}
	
	if (([aTableColumn identifier] != nil) && [[aTableColumn identifier] isEqualToString:@"Value"])
	{
		if (rowIndex >= [ancillaryDataValues count])
			return @"unknown row";
		
		// return ancillary data values
		return [ancillaryDataValues objectAtIndex:rowIndex];
	}
	
	return @"unknown column";
}

- (NSInteger)numberOfRowsInTableView:(NSTableView *)aTableView
{
	return [ancillaryDataValues count];
}

- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)theApplication
{
	return YES;
}

- (void)applicationWillTerminate:(NSNotification *)notification
{
	// Stop the capture and release selected device
	if (selectedDevice != nil)
	{
		[self stopCapture];
	}

	// Disable and release DeckLink device discovery interface
	if (deckLinkDiscovery != nil)
	{
		[deckLinkDiscovery disable];
		[deckLinkDiscovery release];
	}

	// Release all DeckLinkDevice instances
	while([deviceListPopup numberOfItems] > 0)
	{
		DeckLinkInputDevice* device = (DeckLinkInputDevice*)[[deviceListPopup itemAtIndex:0] tag];
		if (device != nil)
		{
			[device release];
		}
		[deviceListPopup removeItemAtIndex:0];
	}

	// Release screen preview callback interface
	screenPreviewCallback = nullptr;

	[ancillaryDataValues release];
	[ancillaryDataTypes release];
}

@end

