/* -LICENSE-START-
 ** Copyright (c) 2023 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation (the
 ** "Software") to use, reproduce, display, distribute, sub-license, execute,
 ** and transmit the Software, and to prepare derivative works of the Software,
 ** and to permit third-parties to whom the Software is furnished to do so, in
 ** accordance with:
 **
 ** (1) if the Software is obtained from Blackmagic Design, the End User License
 ** Agreement for the Software Development Kit (“EULA”) available at
 ** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
 **
 ** (2) if the Software is obtained from any third party, such licensing terms
 ** as notified by that third party,
 **
 ** and all subject to the following:
 **
 ** (3) the copyright notices in the Software and this entire statement,
 ** including the above license grant, this restriction and the following
 ** disclaimer, must be included in all copies of the Software, in whole or in
 ** part, and all derivative works of the Software, unless such copies or
 ** derivative works are solely in the form of machine-executable object code
 ** generated by a source language processor.
 **
 ** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 ** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 **
 ** A copy of the Software is available free of charge at
 ** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
 **
 ** -LICENSE-END-
 */

#include <mutex>
#include <stdexcept>

#import <Foundation/Foundation.h>

#import "DeckLinkOutputDevice.h"

class DeckLinkOutputCallback : public IDeckLinkVideoOutputCallback
{
	using ScheduledFrameCompletedHandler = std::function<void(com_ptr<IDeckLinkVideoFrame>&&, BMDOutputFrameCompletionResult)>;
	using ScheduledPlaybackHasStoppedHandler = std::function<void(void)>;

public:
	DeckLinkOutputCallback();
	virtual ~DeckLinkOutputCallback() = default;
	
	// IDeckLinkVideoOutputCallback interface
	HRESULT		ScheduledFrameCompleted(IDeckLinkVideoFrame* completedFrame, BMDOutputFrameCompletionResult result) override;
	HRESULT		ScheduledPlaybackHasStopped() override;
	
	// IUnknown interface
	HRESULT		QueryInterface(REFIID iid, LPVOID *ppv) override;
	ULONG		AddRef() override;
	ULONG		Release() override;
	
	void	setScheduledFrameCompletedHandler(const ScheduledFrameCompletedHandler& handler) { m_scheduledFrameCompletedHandler = handler; }
	void	setScheduledPlaybackHasStoppedHandler(const ScheduledPlaybackHasStoppedHandler& handler) { m_scheduledPlaybackHasStoppedHandler = handler; }
	
private:
	ScheduledFrameCompletedHandler			m_scheduledFrameCompletedHandler;
	ScheduledPlaybackHasStoppedHandler		m_scheduledPlaybackHasStoppedHandler;
	
	std::atomic<ULONG>						m_refCount;
};


DeckLinkOutputCallback::DeckLinkOutputCallback() :
	m_scheduledFrameCompletedHandler(nullptr),
	m_scheduledPlaybackHasStoppedHandler(nullptr),
	m_refCount(1)
{
}

// IDeckLinkVideoOutputCallback interface

HRESULT DeckLinkOutputCallback::ScheduledFrameCompleted(IDeckLinkVideoFrame* completedFrame, BMDOutputFrameCompletionResult result)
{
	if (m_scheduledFrameCompletedHandler)
		m_scheduledFrameCompletedHandler(com_ptr<IDeckLinkVideoFrame>(completedFrame), result);
	
	return S_OK;
}

HRESULT DeckLinkOutputCallback::ScheduledPlaybackHasStopped()
{
	if (m_scheduledPlaybackHasStoppedHandler)
		m_scheduledPlaybackHasStoppedHandler();
	
	return S_OK;
}

// IUnknown interface

HRESULT DeckLinkOutputCallback::QueryInterface(REFIID iid, LPVOID *ppv)
{
	HRESULT result = S_OK;

	if (ppv == nullptr)
		return E_POINTER;
	
	// Obtain the IUnknown interface and compare it the provided REFIID
	CFUUIDBytes iunknown = CFUUIDGetUUIDBytes(IUnknownUUID);
	if (memcmp(&iid, &iunknown, sizeof(REFIID)) == 0)
	{
		*ppv = this;
		AddRef();
	}
	else if (memcmp(&iid, &IID_IDeckLinkVideoOutputCallback, sizeof(REFIID)) == 0)
	{
		*ppv = static_cast<IDeckLinkVideoOutputCallback*>(this);
		AddRef();
	}
	else
	{
		*ppv = nullptr;
		result = E_NOINTERFACE;
	}
	
	return result;
}

ULONG DeckLinkOutputCallback::AddRef()
{
	return ++m_refCount;
}

ULONG DeckLinkOutputCallback::Release()
{
	ULONG newRefValue = --m_refCount;
	if (newRefValue == 0)
		delete this;
	
	return newRefValue;
}


// DeckLinkOutputDevice private properties and methods

enum class PlaybackState { Idle, Prerolling, Running, Stopping };

@interface DeckLinkOutputDevice()

@property (assign) com_ptr<DeckLinkOutputCallback>		callbackDelegate;
@property (assign, atomic) PlaybackState				state;
@property (readonly) int								videoPrerollSize;
@property dispatch_semaphore_t							stoppedSemaphore;
@property ScheduledFrameCompletedBlock					scheduleFrameCompletedHandler;

- (void)handleScheduledFrameCompleted:(com_ptr<IDeckLinkVideoFrame>)completedFrame
					 completionResult:(BMDOutputFrameCompletionResult)result;
- (void)handleScheduledPlaybackStopped;

@end

// DeckLinkOutputDevice implementation

@implementation DeckLinkOutputDevice

- (instancetype)initWithDeckLink:(const com_ptr<IDeckLink>&)deckLink
		   screenPreviewCallback:(const com_ptr<IDeckLinkScreenPreviewCallback>&)screenPreviewCallback
				videoPrerollSize:(const NSInteger) videoPrerollSize
{
	self = [super init];
	if (self)
	{
		_deckLink = deckLink;
		_deckLinkOutput = com_ptr<IDeckLinkOutput>(IID_IDeckLinkOutput, deckLink);
		if (!_deckLinkOutput)
		{
			return nil;
		}
		
		// Create callback delegate and register handlers
		_callbackDelegate = make_com_ptr<DeckLinkOutputCallback>();
		_callbackDelegate->setScheduledFrameCompletedHandler(^(com_ptr<IDeckLinkVideoFrame> completedFrame,
															 BMDOutputFrameCompletionResult result) {
			[self handleScheduledFrameCompleted:completedFrame
							   completionResult:result];
		});
		_callbackDelegate->setScheduledPlaybackHasStoppedHandler(^{
			[self handleScheduledPlaybackStopped];
		});
		
		// Provide the callback delegate to the audio and video output interfaces
		_deckLinkOutput->SetScheduledFrameCompletionCallback(_callbackDelegate.get());
		
		// Register screen preview callback
		_deckLinkOutput->SetScreenPreviewCallback(screenPreviewCallback.get());
		
		_videoPrerollSize = (int)videoPrerollSize;
		
		_stoppedSemaphore = dispatch_semaphore_create(0);
		
		_state = PlaybackState::Idle;
	}
	return self;
}

- (void)dealloc
{
	[self disableOutput];
	_deckLinkOutput->SetScreenPreviewCallback(nullptr);
	_deckLinkOutput->SetScheduledFrameCompletionCallback(nullptr);
}

- (void)setScheduledFrameCompletedHandler:(const ScheduledFrameCompletedBlock&)block
{
	_scheduleFrameCompletedHandler = block;
}

- (void)handleScheduledFrameCompleted:(com_ptr<IDeckLinkVideoFrame>)completedFrame
					 completionResult:(BMDOutputFrameCompletionResult)result
{
	if (!_scheduleFrameCompletedHandler)
		return;
	
	if (result != bmdOutputFrameFlushed && _state == PlaybackState::Running)
	{
		_scheduleFrameCompletedHandler();
	}
}

- (void)handleScheduledPlaybackStopped
{
	dispatch_semaphore_signal(_stoppedSemaphore);
}

- (BOOL)enableOutputWithDisplayMode:(BMDDisplayMode)displayMode
{
	// Pass through RP188 timecode and VANC from input frame.  VITC timecode is forwarded with VANC
	BMDVideoOutputFlags				outputFlags = bmdVideoOutputFlagDefault;
	com_ptr<IDeckLinkDisplayMode>	deckLinkDisplayMode;

	if (_state != PlaybackState::Idle)
		return false;
	
	if (_deckLinkOutput->GetDisplayMode(displayMode, deckLinkDisplayMode.releaseAndGetAddressOf()) != S_OK)
		return false;

	if (deckLinkDisplayMode->GetFrameRate(&_frameDuration, &_frameTimescale) != S_OK)
		return false;

	_frameWidth = deckLinkDisplayMode->GetWidth();
	_frameHeight = deckLinkDisplayMode->GetHeight();

	if (_deckLinkOutput->EnableVideoOutput(displayMode, outputFlags) != S_OK)
		return false;

	_state = PlaybackState::Prerolling;

	return true;
}

- (void)disableOutput
{
	bool scheduledPlaybackRunning = false;

	// If scheduled playback is running, stop video and audio streams immediately
	if ((_deckLinkOutput->IsScheduledPlaybackRunning(&scheduledPlaybackRunning) == S_OK) && scheduledPlaybackRunning)
	{
		_state = PlaybackState::Stopping;
		
		_deckLinkOutput->StopScheduledPlayback(0, nullptr, 0);
		
		// Wait for the playback completion callback
		dispatch_semaphore_wait(_stoppedSemaphore, DISPATCH_TIME_FOREVER);
	}
	
	// Disable video outputs
	_deckLinkOutput->DisableVideoOutput();

	_state = PlaybackState::Idle;
}

- (BOOL)scheduleVideoFrame:(com_ptr<IDeckLinkVideoFrame>)videoFrame
			  atStreamTime:(BMDTimeValue)streamTime
{
	// Stop scheduling more frames when stopping.
	if (_state == PlaybackState::Stopping)
		return YES;
	
	if (_deckLinkOutput->ScheduleVideoFrame(videoFrame.get(), streamTime, _frameDuration, _frameTimescale) != S_OK)
		return NO;

	if (_state == PlaybackState::Prerolling)
	{
		uint32_t bufferedVideoFrameCount;
		
		// Check whether sufficient video frames have been prerolled and playback can start
		if (_deckLinkOutput->GetBufferedVideoFrameCount(&bufferedVideoFrameCount) != S_OK)
		{
			NSLog(@"Unable to get buffered video frame count");
			return NO;
		}

		if (bufferedVideoFrameCount < _videoPrerollSize)
			return YES;
		
		
		if (_deckLinkOutput->StartScheduledPlayback(0, _frameTimescale, 1.0) != S_OK)
		{
			NSLog(@"Unable to start scheduled playback");
			return NO;
		}
				
		_state = PlaybackState::Running;
	}
	
	return YES;
}

@end
