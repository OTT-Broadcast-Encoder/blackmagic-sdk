/* -LICENSE-START-
 ** Copyright (c) 2023 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation (the
 ** "Software") to use, reproduce, display, distribute, sub-license, execute,
 ** and transmit the Software, and to prepare derivative works of the Software,
 ** and to permit third-parties to whom the Software is furnished to do so, in
 ** accordance with:
 **
 ** (1) if the Software is obtained from Blackmagic Design, the End User License
 ** Agreement for the Software Development Kit (“EULA”) available at
 ** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
 **
 ** (2) if the Software is obtained from any third party, such licensing terms
 ** as notified by that third party,
 **
 ** and all subject to the following:
 **
 ** (3) the copyright notices in the Software and this entire statement,
 ** including the above license grant, this restriction and the following
 ** disclaimer, must be included in all copies of the Software, in whole or in
 ** part, and all derivative works of the Software, unless such copies or
 ** derivative works are solely in the form of machine-executable object code
 ** generated by a source language processor.
 **
 ** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 ** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 **
 ** A copy of the Software is available free of charge at
 ** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
 **
 ** -LICENSE-END-
 */


#import "DeckLinkMetalPreview.h"
#import <Foundation/Foundation.h>
#import <MetalKit/MetalKit.h>

#include <atomic>
#include <functional>

class DeckLinkScreenPreviewCallback : public IDeckLinkScreenPreviewCallback
{
	using RenderFrameHandler = std::function<void(com_ptr<IDeckLinkVideoFrame>&&)>;
															
public:
	DeckLinkScreenPreviewCallback();
	virtual ~DeckLinkScreenPreviewCallback() = default;
	
	// IDeckLinkScreenPreviewCallback interface
	HRESULT	DrawFrame(IDeckLinkVideoFrame* theFrame) override;
	
	// IUnknown interface
	HRESULT	QueryInterface(REFIID iid, LPVOID *ppv) override;
	ULONG	AddRef(void) override;
	ULONG	Release(void) override;

	// Other methods
	void	setRenderFrameHandler(const RenderFrameHandler& handler) { m_renderFrameHandler = handler; }
	
private:
	RenderFrameHandler		m_renderFrameHandler;
	std::atomic<ULONG>		m_refCount;
};

DeckLinkScreenPreviewCallback::DeckLinkScreenPreviewCallback() :
	m_renderFrameHandler(nullptr),
	m_refCount(1)
{
}

HRESULT DeckLinkScreenPreviewCallback::DrawFrame(IDeckLinkVideoFrame* theFrame)
{
	if (m_renderFrameHandler)
		m_renderFrameHandler(com_ptr<IDeckLinkVideoFrame>(theFrame));
	
	return S_OK;
}

HRESULT DeckLinkScreenPreviewCallback::QueryInterface(REFIID iid, LPVOID *ppv)
{
	HRESULT result = S_OK;

	if (ppv == nullptr)
		return E_POINTER;
	
	// Obtain the IUnknown interface and compare it the provided REFIID
	CFUUIDBytes iunknown = CFUUIDGetUUIDBytes(IUnknownUUID);
	if (memcmp(&iid, &iunknown, sizeof(REFIID)) == 0)
	{
		*ppv = this;
		AddRef();
	}
	else if (memcmp(&iid, &IID_IDeckLinkScreenPreviewCallback, sizeof(REFIID)) == 0)
	{
		*ppv = static_cast<IDeckLinkScreenPreviewCallback*>(this);
		AddRef();
	}
	else
	{
		*ppv = nullptr;
		result = E_NOINTERFACE;
	}
	
	return result;
}

ULONG DeckLinkScreenPreviewCallback::AddRef()
{
	return ++m_refCount;
}

ULONG DeckLinkScreenPreviewCallback::Release()
{
	ULONG newRefValue = --m_refCount;
	if (newRefValue == 0)
		delete this;
	
	return newRefValue;
}


@implementation DeckLinkMetalPreview
{
	com_ptr<IDeckLinkMetalScreenPreviewHelper>		_metalScreenPreview;
	com_ptr<DeckLinkScreenPreviewCallback>			_callbackDelegate;
	
	id<MTLDevice>									_device;
	id<MTLCommandQueue>								_commandQueue;
	vector_uint2									_viewportSize;
	
	UpdateDisplayBlock								_updateDisplayHandler;
}

- (nonnull instancetype)initWithMetalKitView:(MTKView *)mtkView;
{
	self = [super init];
	if (self)
	{
		_device = mtkView.device;
		
		// Create and initialize the Metal screen preview helper
		_metalScreenPreview = CreateMetalScreenPreviewHelper();
		NSAssert(_metalScreenPreview, @"Unable to create metal screen preview helper");

		_commandQueue = [_device newCommandQueue];
		_metalScreenPreview->Initialize((__bridge void*)_device);

		// Create callback delegate and register handler
		_callbackDelegate = make_com_ptr<DeckLinkScreenPreviewCallback>();
		__weak __typeof(self) weakSelf = self;
		_callbackDelegate->setRenderFrameHandler(^(com_ptr<IDeckLinkVideoFrame>&& frame) {
			__strong __typeof(self) strongSelf = weakSelf;
			if (strongSelf)
			{
				[strongSelf updateVideoFrame:frame];
			}
		});
	}
	return self;
}

- (void) updateVideoFrame:(com_ptr<IDeckLinkVideoFrame>&)theFrame
{
	// Wrap with autoreleasequeue as call will be from DeckLinkAPI preview thread
	@autoreleasepool {
		if (_metalScreenPreview)
			_metalScreenPreview->SetFrame(theFrame.get());
		
		__block UpdateDisplayBlock updateDisplayHandlerBlock = _updateDisplayHandler;
		dispatch_async(dispatch_get_main_queue(), ^{
			if (updateDisplayHandlerBlock)
			{
				updateDisplayHandlerBlock();
			}
		});
	}
}

- (void)mtkView:(MTKView *)view drawableSizeWillChange:(CGSize)size
{
	// Update viewport with drawable size
	_viewportSize.x = size.width;
	_viewportSize.y = size.height;
}

- (void)drawInMTKView:(MTKView *)view
{
	id<CAMetalDrawable> drawable = [view currentDrawable];
	if (!drawable)
		return;

	id<MTLCommandBuffer> commandBuffer = [_commandQueue commandBuffer];
	
	MTLViewport viewport =
	{
		viewport.originX = 0.0,
		viewport.originY = 0.0,
		viewport.width = (double)_viewportSize.x,
		viewport.height = (double)_viewportSize.y,
		viewport.znear = 0.0,
		viewport.zfar = 1.0
	};
	
	MTLRenderPassDescriptor *drawableRenderPassDescriptor = [view currentRenderPassDescriptor];
	drawableRenderPassDescriptor.colorAttachments[0].texture = drawable.texture;
	drawableRenderPassDescriptor.colorAttachments[0].loadAction = MTLLoadActionClear;
	drawableRenderPassDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(0.0, 0.0, 0.0, 1.0);
	drawableRenderPassDescriptor.colorAttachments[0].storeAction = MTLStoreActionStore;
	_metalScreenPreview->Draw((__bridge void*)commandBuffer,
							  (__bridge void*)drawableRenderPassDescriptor,
							  (void*)&viewport);
	
	[commandBuffer presentDrawable:drawable];
	[commandBuffer commit];
}

- (void)setUpdateDisplayHandler:(const UpdateDisplayBlock)block
{
	_updateDisplayHandler = block;
}

- (com_ptr<IDeckLinkScreenPreviewCallback>)delegate
{
	return com_ptr<IDeckLinkScreenPreviewCallback>(_callbackDelegate.get());
}

@end
