/* -LICENSE-START-
 ** Copyright (c) 2023 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation (the
 ** "Software") to use, reproduce, display, distribute, sub-license, execute,
 ** and transmit the Software, and to prepare derivative works of the Software,
 ** and to permit third-parties to whom the Software is furnished to do so, in
 ** accordance with:
 **
 ** (1) if the Software is obtained from Blackmagic Design, the End User License
 ** Agreement for the Software Development Kit (“EULA”) available at
 ** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
 **
 ** (2) if the Software is obtained from any third party, such licensing terms
 ** as notified by that third party,
 **
 ** and all subject to the following:
 **
 ** (3) the copyright notices in the Software and this entire statement,
 ** including the above license grant, this restriction and the following
 ** disclaimer, must be included in all copies of the Software, in whole or in
 ** part, and all derivative works of the Software, unless such copies or
 ** derivative works are solely in the form of machine-executable object code
 ** generated by a source language processor.
 **
 ** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 ** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 **
 ** A copy of the Software is available free of charge at
 ** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
 **
 ** -LICENSE-END-
 */

@import MetalKit;
@import CoreVideo;
@import SceneKit;

#import "OutputRenderer.h"
#import "Cube.h"
#import "Pyramid.h"
#import "ShaderTypes.h"


simd_float4x4 getRotationMatrix(float angle, simd_float3 axis)
{
	float rad = M_PI * angle / 180.0;
	SCNMatrix4 matrix = SCNMatrix4MakeRotation(rad, axis.x, axis.y, axis.z);
	return SCNMatrix4ToMat4(matrix);
}

simd_float4x4 getScaleMatrix(simd_float3 scale)
{
	SCNMatrix4 matrix = SCNMatrix4MakeScale(scale.x, scale.y, scale.z);
	return SCNMatrix4ToMat4(matrix);
}

simd_float4x4 getTranslateMatrix(simd_float3 translate)
{
	SCNMatrix4 matrix = SCNMatrix4MakeTranslation(translate.x, translate.y, translate.z);
	return SCNMatrix4ToMat4(matrix);
}

simd_float4x4 getPerspectiveMatrix(float fovy, float aspect, float zNear, float zFar)
{
	float fovyRadians = M_PI * fovy / 180.0;
	float f = 1.0 / tan(fovyRadians/2);
	
	return simd_matrix_from_rows (
		simd_make_float4( f/aspect, 0.0,  0.0,                        0.0                       ),
		simd_make_float4( 0.0,      f,    0.0,                        0.0                       ),
		simd_make_float4( 0.0,      0.0,  (zFar+zNear)/(zFar-zNear),  2*zFar*zNear/(zNear-zFar) ),
		simd_make_float4( 0.0,      0.0,  -1.0,                       0.0                       )
	);
}

// The main class performing the rendering.
@implementation OutputRenderer
{
	id<MTLDevice> _device;

	id<MTLCommandQueue> _commandQueue;

	id<MTLRenderPipelineState> _renderPipelineState;
	id<MTLDepthStencilState> _depthStencilState;

	MTLPixelFormat _pixelFormat;
	id<MTLTexture> _depthTexture;

	Pyramid* _pyramidVertice;
	Cube* cubeMatrix;

	float _pyramidRotationAngle;
	float _cubeRotationAngle;

	CVMetalTextureCacheRef _textureCache;
}


- (nonnull instancetype)initWithTextureSize:(NSSize)textureSize
								pixelFormat:(MTLPixelFormat)pixelFormat
{
	self = [super init];
	if (self)
	{
		_device = MTLCreateSystemDefaultDevice();
		
		_pixelFormat = pixelFormat;
		
		// Setup texture descriptor for depth buffer.
		// First check whether we can support memoryless render target
		// see: https://developer.apple.com/metal/Metal-Feature-Set-Tables.pdf
		BOOL memorylessSupported = [_device supportsFamily:MTLGPUFamilyApple2];
		
		MTLPixelFormat depthTextureFormat = MTLPixelFormatDepth32Float;
		MTLTextureDescriptor *depthTextureDescriptor = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:depthTextureFormat
																										  width:textureSize.width
																										 height:textureSize.height
																									  mipmapped:NO];
		depthTextureDescriptor.usage = MTLTextureUsageRenderTarget;
		depthTextureDescriptor.storageMode = memorylessSupported ? MTLStorageModeMemoryless : MTLStorageModePrivate;
		
		_depthTexture = [_device newTextureWithDescriptor:depthTextureDescriptor];
		_depthTexture.label = @"Depth Texture";
		
		// Load vertex and fragment shaders from metal file
		id<MTLLibrary> library = [_device newDefaultLibrary];
		id<MTLFunction> vertexFunction = [library newFunctionWithName:@"vertexShader"];
		id<MTLFunction> fragmentFunction = [library newFunctionWithName:@"fragmentShader"];
		
		// Create render pipeline descriptor
		MTLRenderPipelineDescriptor* pipelineDescriptor = [[MTLRenderPipelineDescriptor alloc] init];
		pipelineDescriptor.label = @"Offscreen Metal Render Pipeline";
		pipelineDescriptor.sampleCount = 1;
		pipelineDescriptor.vertexFunction = vertexFunction;
		pipelineDescriptor.fragmentFunction = fragmentFunction;
		pipelineDescriptor.colorAttachments[0].pixelFormat = pixelFormat;
		pipelineDescriptor.depthAttachmentPixelFormat = depthTextureFormat;
		pipelineDescriptor.stencilAttachmentPixelFormat = MTLPixelFormatInvalid;
		pipelineDescriptor.vertexBuffers[VertexShaderInputIndexVertices].mutability = MTLMutabilityImmutable;
		
		NSError* error;
		_renderPipelineState = [_device newRenderPipelineStateWithDescriptor:pipelineDescriptor error:&error];
		NSAssert(_renderPipelineState, @"Failed to create render pipeline state: %@", error);

		// Create depth stencil descriptor
		MTLDepthStencilDescriptor* depthStencilDescriptor = [[MTLDepthStencilDescriptor alloc] init];
		depthStencilDescriptor.depthCompareFunction = MTLCompareFunctionLess;
		depthStencilDescriptor.depthWriteEnabled = YES;
		_depthStencilState = [_device newDepthStencilStateWithDescriptor:depthStencilDescriptor];

		// Create the command queue.
		_commandQueue = [_device newCommandQueue];
		
		NSDictionary<NSString *, id> *cacheAttributes = @{
			(__bridge NSString *)kCVMetalTextureCacheMaximumTextureAgeKey: @0.5,
		};
		
		NSDictionary<NSString *, id> *textureAttributes = @{
			(__bridge NSString *)kCVMetalTextureUsage: @(MTLTextureUsageRenderTarget),
		};
		
		CVReturn status = CVMetalTextureCacheCreate(
			NULL,
			(__bridge CFDictionaryRef)cacheAttributes,
			_device,
			(__bridge CFDictionaryRef)textureAttributes,
			&_textureCache
		);
		NSAssert(_textureCache != NULL, @"Failed to create texture cache: %d", status);
	}
	return self;
}

- (void)drawToPixelBuffer:(CVPixelBufferRef)pixelBuffer
	withCompletionHandler:(nullable RenderCompletedBlock)completionBlock
{
	// Update rotation angle
	_pyramidRotationAngle += 0.8;
	_cubeRotationAngle -= 0.6f;
	
	// Create new command buffer for each rendering pass
	id<MTLCommandBuffer> commandBuffer = [_commandQueue commandBuffer];
	commandBuffer.label = @"MetalOutputCommandBuffer";
	
	size_t width = CVPixelBufferGetWidth(pixelBuffer);
	size_t height = CVPixelBufferGetHeight(pixelBuffer);

	// Get the cached texture associated with CVPixelBuffer
	CVMetalTextureRef renderTexture = NULL;
	CVReturn status = CVMetalTextureCacheCreateTextureFromImage(
		NULL,
		_textureCache,
		pixelBuffer,
		NULL,
		_pixelFormat,
		width,
		height,
		0,
		&renderTexture
	);
	NSAssert(renderTexture != NULL, @"Failed to create render texture %d", status);

	// Define offscreen render pass
	MTLRenderPassDescriptor* renderPassDescriptor = [MTLRenderPassDescriptor new];
	renderPassDescriptor.colorAttachments[0].texture = CVMetalTextureGetTexture(renderTexture);
	renderPassDescriptor.colorAttachments[0].loadAction = MTLLoadActionClear;
	renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(0.0, 0.0, 0.0, 1.0);
	renderPassDescriptor.colorAttachments[0].storeAction = MTLStoreActionStore;
	
	// Define depth buffer
	renderPassDescriptor.depthAttachment.texture = _depthTexture;
	renderPassDescriptor.depthAttachment.loadAction = MTLLoadActionClear;
	renderPassDescriptor.depthAttachment.clearDepth = 1.0;
	renderPassDescriptor.depthAttachment.storeAction = MTLStoreActionDontCare;

	// Create a render command encoder
	id<MTLRenderCommandEncoder> renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];
	renderEncoder.label = @"MetalOutputRenderEncoder";
	
	// Set render command encoder state.
	[renderEncoder setRenderPipelineState:_renderPipelineState];
	
	// Set depth stancil and cull mode
	[renderEncoder setDepthStencilState:_depthStencilState];
	[renderEncoder setFrontFacingWinding:MTLWindingCounterClockwise];
	[renderEncoder setCullMode:MTLCullModeBack];
	
	// Set rotation, translation, scale and perspective transformations for pyramid
	Uniforms shaderUniforms;
	shaderUniforms.rotationMatrix = getRotationMatrix(_pyramidRotationAngle, simd_make_float3(0.0, 1.0, 0.0));
	shaderUniforms.translationMatrix = getTranslateMatrix(simd_make_float3(-1.5, 0.0, 6.0));
	shaderUniforms.scaleMatrix = getScaleMatrix(simd_make_float3(0.18, 0.18, 0.18));
	shaderUniforms.perspectiveMatrix = getPerspectiveMatrix(45.0f, width / (float)height, 0.1f, 100.0f);
	[renderEncoder setVertexBytes:&shaderUniforms
						   length:sizeof(Uniforms)
						  atIndex:VertexShaderInputIndexUniforms];
	
	// Set the current vertex buffer.
	[renderEncoder setVertexBytes:&[Pyramid vertices][0]
						   length:[Pyramid byteSize]
						  atIndex:VertexShaderInputIndexVertices];

	// Draw the triangle vertices.
	[renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle
					  vertexStart:0
					  vertexCount:[Pyramid vertexCount]];

	// Set rotation, translation, scale and perspective transformations for cube
	shaderUniforms.rotationMatrix = getRotationMatrix(_cubeRotationAngle, simd_make_float3(1.0, 1.0, 1.0));
	shaderUniforms.translationMatrix = getTranslateMatrix(simd_make_float3(1.5, 0.0, 7.0));
	shaderUniforms.scaleMatrix = getScaleMatrix(simd_make_float3(0.15, 0.15, 0.15));

	[renderEncoder setVertexBytes:&shaderUniforms
						   length:sizeof(Uniforms)
						  atIndex:VertexShaderInputIndexUniforms];
	
	// Set the current vertex buffer.
	[renderEncoder setVertexBytes:&[Cube vertices][0]
						   length:[Cube byteSize]
						  atIndex:VertexShaderInputIndexVertices];

	// Draw the triangle vertices.
	[renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle
					  vertexStart:0
					  vertexCount:[Cube vertexCount]];
	
	// Finalize encoding.
	[renderEncoder endEncoding];

	// Setup completion handler to signal to draw task that Metal has completed with frame
	__block RenderCompletedBlock completedHandlerCompletionBlock = completionBlock;
	[commandBuffer addCompletedHandler:^(id<MTLCommandBuffer> buffer)
	{
		if (completedHandlerCompletionBlock)
			completedHandlerCompletionBlock();
		
		CFRelease(renderTexture);
	}];
	
	// Finalize CPU work and submit the command buffer to the GPU.
	[commandBuffer commit];
}

@end
