/* -LICENSE-START-
 ** Copyright (c) 2023 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation (the
 ** "Software") to use, reproduce, display, distribute, sub-license, execute,
 ** and transmit the Software, and to prepare derivative works of the Software,
 ** and to permit third-parties to whom the Software is furnished to do so, in
 ** accordance with:
 **
 ** (1) if the Software is obtained from Blackmagic Design, the End User License
 ** Agreement for the Software Development Kit (“EULA”) available at
 ** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
 **
 ** (2) if the Software is obtained from any third party, such licensing terms
 ** as notified by that third party,
 **
 ** and all subject to the following:
 **
 ** (3) the copyright notices in the Software and this entire statement,
 ** including the above license grant, this restriction and the following
 ** disclaimer, must be included in all copies of the Software, in whole or in
 ** part, and all derivative works of the Software, unless such copies or
 ** derivative works are solely in the form of machine-executable object code
 ** generated by a source language processor.
 **
 ** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 ** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 **
 ** A copy of the Software is available free of charge at
 ** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
 **
 ** -LICENSE-END-
 */

#import "MetalOutput.h"
#import "DeckLinkOutputDevice.h"
#import "OutputRenderer.h"

#include "DeckLinkCVVideoFrame.h"

static const BMDDisplayMode kOutputDisplayMode = bmdModeHD1080p2997;
static const unsigned kOutputPrerollSize = 3;
static const OSType kOutputCVPixelFormat = kCVPixelFormatType_32BGRA;
static const unsigned kOutputBytesPerPixel = 4;  // kCVPixelFormatType_32BGRA = 4 bytes per pixel

@implementation MetalOutput
{
	id<MTLDevice> _device;

	CVPixelBufferPoolRef _pixelBufferPool;
	
	DeckLinkOutputDevice* _deckLinkOutputDevice;
	DeckLinkMetalPreview* _deckLinkMetalPreview;
	
	OutputRenderer* _outputRenderer;
	
	BMDTimeValue _outputDisplayTime;
	
	CGSize	_frameSize;
}

- (instancetype)initWithMetalPreview:(DeckLinkMetalPreview*)metalPreview
{
	self = [super init];
	if (self)
	{
		_deckLinkMetalPreview = metalPreview;
		
		// Obtain DeckLink iterator object
		com_ptr<IDeckLinkIterator> deckLinkIterator = com_ptr<IDeckLinkIterator>(CreateDeckLinkIteratorInstance());
		NSAssert(deckLinkIterator, @"This application requires the Desktop Video drivers installed.");
		
		// Select the first DeckLink device
		HRESULT result;
		com_ptr<IDeckLink> deckLink;
		result = deckLinkIterator->Next(deckLink.releaseAndGetAddressOf());
		NSAssert(result == S_OK, @"No Desktop Video devices were found.");
		
		_deckLinkOutputDevice = [[DeckLinkOutputDevice alloc] initWithDeckLink:deckLink
														 screenPreviewCallback:[_deckLinkMetalPreview delegate]
															  videoPrerollSize:kOutputPrerollSize];
		NSAssert(_deckLinkOutputDevice, @"The selected Desktop Video device does not have an output interface");
		
		com_ptr<IDeckLinkDisplayMode> deckLinkDisplayMode;
		result = [_deckLinkOutputDevice deckLinkOutput]->GetDisplayMode(kOutputDisplayMode, deckLinkDisplayMode.releaseAndGetAddressOf());
		NSAssert(result == S_OK, @"Could not get output display mode.");
		
		NSSize textureSize = { (double)deckLinkDisplayMode->GetWidth(), (double)deckLinkDisplayMode->GetHeight() };
		_outputRenderer = [[OutputRenderer alloc] initWithTextureSize:textureSize
														  pixelFormat:MTLPixelFormatBGRA8Unorm];
		NSAssert(_outputRenderer, @"Could not configure scene renderer");
		
		// Initialize the pixel buffer pool to allocate texture buffers
		// Ensure that the CVPixelBuffers are IOSurface backed and have Metal comptibility
		NSDictionary<NSString*, id> *poolAttributes = @{
			(__bridge NSString*)kCVPixelBufferPoolMinimumBufferCountKey:@3,
			(__bridge NSString*)kCVPixelBufferPoolMaximumBufferAgeKey:@0.5,
		};
		
		NSDictionary<NSString*, id> *pixelBufferAttributes = @{
			(__bridge NSString*)kCVPixelBufferPixelFormatTypeKey : @(kOutputCVPixelFormat),
			(__bridge NSString*)kCVPixelBufferWidthKey : @(deckLinkDisplayMode->GetWidth()),
			(__bridge NSString*)kCVPixelBufferHeightKey : @(deckLinkDisplayMode->GetHeight()),
			(__bridge NSString*)kCVPixelBufferBytesPerRowAlignmentKey : @(deckLinkDisplayMode->GetWidth() * kOutputBytesPerPixel),
			(__bridge NSString*)kCVPixelBufferIOSurfacePropertiesKey : @{},
			(__bridge NSString*)kCVPixelBufferMetalCompatibilityKey : @YES,
		};
		
		CVPixelBufferPoolCreate(NULL, (__bridge CFDictionaryRef)poolAttributes, (__bridge CFDictionaryRef)pixelBufferAttributes, &_pixelBufferPool);
		NSAssert(_pixelBufferPool, @"Could not create CVPixelBufferPool.");
		
		_outputDisplayTime = 0;
	}
	return self;
}

- (void)dealloc
{
	[self stopRendering];
	CVPixelBufferPoolRelease(_pixelBufferPool);
}

- (BOOL)startRendering
{
	// Set handler for scheduled frame completed callback
	__block MetalOutput* selfBlock = self;
	[_deckLinkOutputDevice setScheduledFrameCompletedHandler:^() {
		// Render next video frame
		[selfBlock renderVideoFrame];
	}];
	
	// Enable DeckLink output
	if (![_deckLinkOutputDevice enableOutputWithDisplayMode:kOutputDisplayMode])
	{
		NSLog(@"Could not enable video output.");
		return NO;
	}
	
	// Render to initial preroll frames
	for (unsigned i = 0; i < kOutputPrerollSize; ++i)
	{
		[selfBlock renderVideoFrame];
	}
	
	_outputDisplayTime = 0;
	
	return YES;
}

- (void)stopRendering
{
	[_deckLinkOutputDevice disableOutput];
}

- (void)renderVideoFrame
{
	// Get CVPixelBuffer from pool
	CVPixelBufferRef pixelBuffer = NULL;
	CVPixelBufferPoolCreatePixelBuffer(NULL, _pixelBufferPool, &pixelBuffer);
	NSAssert(pixelBuffer, @"Unable to create CVPixelBuffer from pool.");
	
	__block DeckLinkOutputDevice* deckLinkOutputDeviceBlock = _deckLinkOutputDevice;
	__block BMDTimeValue outputDisplayTimeBlock = _outputDisplayTime;
	__block CVPixelBufferRef pixelBufferBlock = pixelBuffer;
	
	[_outputRenderer drawToPixelBuffer:pixelBuffer
				 withCompletionHandler:^{
		com_ptr<DeckLinkCVVideoFrame> videoFrame = make_com_ptr<DeckLinkCVVideoFrame>(pixelBufferBlock);
		
		// The DeckLinkCVVideoFrame now retains the CVPixelBuffer, so we can release here
		CVPixelBufferRelease(pixelBufferBlock);
		
		[deckLinkOutputDeviceBlock scheduleVideoFrame:com_ptr<IDeckLinkVideoFrame>(IID_IDeckLinkVideoFrame, videoFrame)
										 atStreamTime:outputDisplayTimeBlock];
	}];
	
	_outputDisplayTime += _deckLinkOutputDevice.frameDuration;
}

@end
