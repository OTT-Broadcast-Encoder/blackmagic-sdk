/* -LICENSE-START-
 ** Copyright (c) 2023 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation (the
 ** "Software") to use, reproduce, display, distribute, sub-license, execute,
 ** and transmit the Software, and to prepare derivative works of the Software,
 ** and to permit third-parties to whom the Software is furnished to do so, in
 ** accordance with:
 **
 ** (1) if the Software is obtained from Blackmagic Design, the End User License
 ** Agreement for the Software Development Kit (“EULA”) available at
 ** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
 **
 ** (2) if the Software is obtained from any third party, such licensing terms
 ** as notified by that third party,
 **
 ** and all subject to the following:
 **
 ** (3) the copyright notices in the Software and this entire statement,
 ** including the above license grant, this restriction and the following
 ** disclaimer, must be included in all copies of the Software, in whole or in
 ** part, and all derivative works of the Software, unless such copies or
 ** derivative works are solely in the form of machine-executable object code
 ** generated by a source language processor.
 **
 ** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 ** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 **
 ** A copy of the Software is available free of charge at
 ** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
 **
 ** -LICENSE-END-
 */


#include <stdexcept>
#import "SyncController.h"
#import "DeckLinkOutputDevice.h"

class DeckLinkOutputCallback : public IDeckLinkVideoOutputCallback, public IDeckLinkAudioOutputCallback
{
	using ScheduledFrameCompletedHandler = std::function<void(com_ptr<IDeckLinkVideoFrame>, BMDOutputFrameCompletionResult)>;
	using RenderAudioSamplesHandler = std::function<void(bool)>;

public:
	DeckLinkOutputCallback();
	virtual ~DeckLinkOutputCallback() = default;
	
	// IUnknown interface
	HRESULT		QueryInterface(REFIID iid, LPVOID *ppv) override;
	ULONG		AddRef() override;
	ULONG		Release() override;
	
	// IDeckLinkVideoOutputCallback interface
	HRESULT		ScheduledFrameCompleted(IDeckLinkVideoFrame* completedFrame, BMDOutputFrameCompletionResult result) override;
	HRESULT		ScheduledPlaybackHasStopped() override;
	
	// IDeckLinkAudioOutputCallback interface
	HRESULT		RenderAudioSamples(bool preroll) override;

	void	setScheduledFrameCompletedHandler(const ScheduledFrameCompletedHandler& handler) { m_scheduledFrameCompletedHandler = handler; }
	void	setRenderAudioSamplesHandler(const RenderAudioSamplesHandler& handler) { m_renderAudioSamplesHandler = handler; }
	
private:
	ScheduledFrameCompletedHandler			m_scheduledFrameCompletedHandler;
	RenderAudioSamplesHandler				m_renderAudioSamplesHandler;
	
	std::atomic<ULONG>						m_refCount;
};


DeckLinkOutputCallback::DeckLinkOutputCallback() :
	m_scheduledFrameCompletedHandler(nullptr),
	m_renderAudioSamplesHandler(nullptr),
	m_refCount(1)
{
}

HRESULT DeckLinkOutputCallback::QueryInterface(REFIID iid, LPVOID *ppv)
{
	HRESULT result = S_OK;

	if (ppv == nullptr)
		return E_POINTER;
	
	// Obtain the IUnknown interface and compare it the provided REFIID
	CFUUIDBytes iunknown = CFUUIDGetUUIDBytes(IUnknownUUID);
	if (memcmp(&iid, &iunknown, sizeof(REFIID)) == 0)
	{
		*ppv = this;
		AddRef();
	}
	else if (memcmp(&iid, &IID_IDeckLinkVideoOutputCallback, sizeof(REFIID)) == 0)
	{
		*ppv = static_cast<IDeckLinkVideoOutputCallback*>(this);
		AddRef();
	}
	else if (memcmp(&iid, &IID_IDeckLinkAudioOutputCallback, sizeof(REFIID)) == 0)
	{
		*ppv = static_cast<IDeckLinkAudioOutputCallback*>(this);
		AddRef();
	}
	else
	{
		*ppv = nullptr;
		result = E_NOINTERFACE;
	}
	
	return result;
}

ULONG DeckLinkOutputCallback::AddRef()
{
	return ++m_refCount;
}

ULONG DeckLinkOutputCallback::Release()
{
	ULONG newRefValue = --m_refCount;
	if (newRefValue == 0)
		delete this;
	
	return newRefValue;
}

// IDeckLinkVideoOutputCallback interface
HRESULT DeckLinkOutputCallback::ScheduledFrameCompleted(IDeckLinkVideoFrame* completedFrame, BMDOutputFrameCompletionResult result)
{
	if (m_scheduledFrameCompletedHandler)
		m_scheduledFrameCompletedHandler(com_ptr<IDeckLinkVideoFrame>(completedFrame), result);
	
	return S_OK;
}

HRESULT DeckLinkOutputCallback::ScheduledPlaybackHasStopped()
{
	return S_OK;
}

// IDeckLinkAudioOutputCallback interface
HRESULT DeckLinkOutputCallback::RenderAudioSamples(bool preroll)
{
	if (m_renderAudioSamplesHandler)
		m_renderAudioSamplesHandler(preroll);
	
	return S_OK;
}

// DeckLinkOutputDevice private properties and methods

@interface DeckLinkOutputDevice()

@property (assign) SyncController*						uiDelegate;
@property (assign) com_ptr<IDeckLinkConfiguration>		deckLinkConfig;
@property (assign) com_ptr<DeckLinkOutputCallback>		callbackDelegate;

- (void)handleScheduledFrameCompleted:(com_ptr<IDeckLinkVideoFrame>)completedFrame
					 completionResult:(BMDOutputFrameCompletionResult)result;
- (void)handleRenderAudioSamples:(BOOL)preroll;

@end

// DeckLinkOutputDevice implementation

@implementation DeckLinkOutputDevice

- (instancetype)initWithDeckLink:(const com_ptr<IDeckLink>&)deckLink syncController:(SyncController*)uiDelegate
{
	self = [super init];
	if (self)
	{
		_uiDelegate = uiDelegate;
		
		_deckLink = deckLink;
		_deckLinkOutput = com_ptr<IDeckLinkOutput>(IID_IDeckLinkOutput, deckLink);
		_deckLinkConfig = com_ptr<IDeckLinkConfiguration>(IID_IDeckLinkConfiguration, deckLink);
		
		if (!_deckLinkOutput || !_deckLinkConfig)
		{
			[super dealloc];
			return nil;
		}
		
		// Create callback delegate and register handlers
		_callbackDelegate = make_com_ptr<DeckLinkOutputCallback>();
		_callbackDelegate->setScheduledFrameCompletedHandler(^(com_ptr<IDeckLinkVideoFrame> completedFrame,
															 BMDOutputFrameCompletionResult result) {
			[self handleScheduledFrameCompleted:completedFrame
							   completionResult:result];
		});
		_callbackDelegate->setRenderAudioSamplesHandler(^(BOOL preroll) {
			[self handleRenderAudioSamples:preroll];
		});
		
		// Provide the callback delegate to the audio and video output interfaces
		_deckLinkOutput->SetScheduledFrameCompletionCallback(_callbackDelegate.get());
		_deckLinkOutput->SetAudioCallback(_callbackDelegate.get());
		
		_videoPrerollSize = 30;
		_audioWaterLevel = 48000;
	}
	return self;
}

- (void)dealloc
{
	_deckLinkOutput->SetScheduledFrameCompletionCallback(nullptr);
	_deckLinkOutput->SetAudioCallback(nullptr);
	
	[super dealloc];
}

- (void)queryDisplayModesWithBlock:(const QueryDisplayModeBlock&)block
{
	com_ptr<IDeckLinkDisplayModeIterator>	displayModeIterator;
	com_ptr<IDeckLinkDisplayMode>			displayMode;

	if (block == nil)
		return;
	
	if (_deckLinkOutput->GetDisplayModeIterator(displayModeIterator.releaseAndGetAddressOf()) != S_OK)
		return;

	while (displayModeIterator->Next(displayMode.releaseAndGetAddressOf()) == S_OK)
	{
		BMDDisplayMode bmdDisplayMode = displayMode->GetDisplayMode();
		HRESULT hr;
		CFStringRef displayModeCFString;
		bool supported;
		
		hr = _deckLinkOutput->DoesSupportVideoMode(bmdVideoConnectionUnspecified, bmdDisplayMode, bmdFormatUnspecified,
												  bmdNoVideoInputConversion, bmdSupportedVideoModeDefault, nullptr, &supported);
		if (hr != S_OK || !supported)
			continue;
		
		hr = displayMode->GetName(&displayModeCFString);
		if (hr != S_OK)
			continue;
		
		NSString* displayModeName = [NSString stringWithString: (NSString *)displayModeCFString];
		CFRelease(displayModeCFString);

		block(bmdDisplayMode, displayModeName);
	}
}

- (BOOL)isActive
{
	com_ptr<IDeckLinkProfileAttributes> deckLinkAttributes(IID_IDeckLinkProfileAttributes, _deckLink);
	int64_t intAttribute;

	if (!deckLinkAttributes)
		return NO;

	if (deckLinkAttributes->GetInt(BMDDeckLinkDuplex, &intAttribute) != S_OK)
		return NO;

	return ((BMDDuplexMode) intAttribute) != bmdDuplexInactive;
}

- (NSString*)deviceName
{
	CFStringRef displayNameCFString;
	NSString* displayName;
	
	if (_deckLink->GetDisplayName(&displayNameCFString) == S_OK)
	{
		displayName = [NSString stringWithString:(NSString*)displayNameCFString];
		CFRelease(displayNameCFString);
	}
	else
	{
		displayName = @"DeckLink";
	}

	return displayName;
}

- (BOOL)supportsHFRTimecode
{
	bool attributeFlag;
	com_ptr<IDeckLinkProfileAttributes> deckLinkAttributes(IID_IDeckLinkProfileAttributes, _deckLink);

	if (!deckLinkAttributes)
		return NO;
	
	if (deckLinkAttributes->GetFlag(BMDDeckLinkSupportsHighFrameRateTimecode,
									 &attributeFlag) != S_OK)
		return NO;
	
	return attributeFlag ? YES : NO;
}

- (NSInteger)maximumAudioChannels
{
	int64_t attributeInt;
	com_ptr<IDeckLinkProfileAttributes> deckLinkAttributes(IID_IDeckLinkProfileAttributes, _deckLink);

	if (!deckLinkAttributes)
		return 0;
	
	// Get max number of audio channels supported by DeckLink device
	if (deckLinkAttributes->GetInt(BMDDeckLinkMaximumAudioChannels, &attributeInt) != S_OK)
		return 0;

	return (NSInteger)attributeInt;
}

- (BOOL)output444
{
	bool output444;
	if (_deckLinkConfig->GetFlag(bmdDeckLinkConfig444SDIVideoOutput, &output444) != S_OK)
		output444 = false;
	
	return output444 ? YES : NO;
}

- (void)setOutput444
{
	(void)_deckLinkConfig->SetFlag(bmdDeckLinkConfig444SDIVideoOutput, _output444);
}


- (void)handleScheduledFrameCompleted:(com_ptr<IDeckLinkVideoFrame>)completedFrame
					 completionResult:(BMDOutputFrameCompletionResult)result
{
	[_uiDelegate scheduleNextFrame:NO];
}

- (void)handleRenderAudioSamples:(BOOL)preroll
{
	unsigned int bufferedAudioSampleCount;

	// Check audio water level and request further samples if required
	if (_deckLinkOutput->GetBufferedAudioSampleFrameCount(&bufferedAudioSampleCount) == S_OK)
	{
		if (bufferedAudioSampleCount < _audioWaterLevel)
			// Provide further audio samples until our preferred buffer waterlevel is reached
			[_uiDelegate writeNextAudioSamples:(_audioWaterLevel - bufferedAudioSampleCount)];

		if (preroll)
		{
			// Ensure that both audio and video preroll have sufficient samples, then commence scheduled playback
			unsigned int bufferedVideoFrameCount;

			if (_deckLinkOutput->GetBufferedVideoFrameCount(&bufferedVideoFrameCount) == S_OK)
			{
				if ((bufferedAudioSampleCount >= _audioWaterLevel) && (bufferedVideoFrameCount >= _videoPrerollSize))
				{
					// Start audio and video output
					_deckLinkOutput->StartScheduledPlayback(0, 100, 1.0);
				}
			}
		}
	}
}

@end
